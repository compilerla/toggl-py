"""
Public Toggl API. Note: We use BasicAuth in a specific way. By the standard you provide `Authentication` header with `base64(user_name:password)` as a `credential`. In our case it will be `base64(user_name:api_token)`.  # noqa: E501

This file is auto generated by the swagger code generator program.
Do not edit this file manually.

OpenAPI spec version: 9
Generated by: https://github.com/compilerla/toggl-py
"""

import re  # noqa: F401

from toggl.api_client import ApiClient
from toggl.models.dashboard_all_activities import DashboardAllActivities  # noqa: F401
from toggl.models.models_most_active_user import ModelsMostActiveUser  # noqa: F401


class DashboardApi:

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def get_workspace_all_activities(self, workspace_id: int, **kwargs) -> list[DashboardAllActivities]:  # noqa: E501
        """Get last activity for every workspace user  # noqa: E501

        Dashboard's main purpose is to give an overview of what users in the workspace are doing and have been doing. The activity object holds the data of 20 latest actions in the workspace or latest activity for every workspace user. Activity object has the following properties * user_id: user ID * project_id: project ID (ID is 0 if time entry doesn't have project connected to it) * duration: time entry duration in seconds. If the time entry is currently running, the duration attribute contains a negative value, denoting the start of the time entry in seconds since epoch (Jan 1 1970). The correct duration can be calculated as current_time + duration, where current_time is the current time in seconds since epoch. * description: (Description property is not present if time entry description is empty) * stop: time entry stop time (ISO 8601 date and time. Stop property is not present when time entry is still running) * tid: task id, if applicable  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_all_activities(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int workspace_id: Numeric ID of the workspace (required)
        :param int since: Filter activities since this date using UNIX timestamp.
        :return: list[DashboardAllActivities]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_workspace_all_activities_with_http_info(workspace_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_workspace_all_activities_with_http_info(workspace_id, **kwargs)  # noqa: E501
            return data

    def get_workspace_all_activities_with_http_info(
        self, workspace_id: int, **kwargs
    ) -> list[DashboardAllActivities]:  # noqa: E501
        """Get last activity for every workspace user  # noqa: E501

        Dashboard's main purpose is to give an overview of what users in the workspace are doing and have been doing. The activity object holds the data of 20 latest actions in the workspace or latest activity for every workspace user. Activity object has the following properties * user_id: user ID * project_id: project ID (ID is 0 if time entry doesn't have project connected to it) * duration: time entry duration in seconds. If the time entry is currently running, the duration attribute contains a negative value, denoting the start of the time entry in seconds since epoch (Jan 1 1970). The correct duration can be calculated as current_time + duration, where current_time is the current time in seconds since epoch. * description: (Description property is not present if time entry description is empty) * stop: time entry stop time (ISO 8601 date and time. Stop property is not present when time entry is still running) * tid: task id, if applicable  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_all_activities_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int workspace_id: Numeric ID of the workspace (required)
        :param int since: Filter activities since this date using UNIX timestamp.
        :return: list[DashboardAllActivities]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["workspace_id", "since"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method get_workspace_all_activities" % key)
            params[key] = val
        del params["kwargs"]
        # verify the required parameter "workspace_id" is set
        if self.api_client.client_side_validation and (
            "workspace_id" not in params or params["workspace_id"] is None  # noqa: E501
        ):
            raise ValueError(
                "Missing the required parameter `workspace_id` when calling `get_workspace_all_activities`"  # noqa: E501
            )

        collection_formats = {}

        path_params = {}
        if "workspace_id" in params:
            path_params["workspace_id"] = params["workspace_id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "since" in params:
            form_params.append(("since", params["since"]))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = ["BasicAuth"]  # noqa: E501

        return self.api_client.call_api(
            "/workspaces/{workspace_id}/dashboard/all_activity",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="list[DashboardAllActivities]",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_workspace_most_active(self, workspace_id: int, **kwargs) -> list[ModelsMostActiveUser]:  # noqa: E501
        """Get most active users  # noqa: E501

        Dashboard's main purpose is to give an overview of what users in the workspace are doing and have been doing. The most active user object holds the data of the top 5 users who have tracked the most time during last 7 days. Most active user object has the following properties * user_id: user ID * duration: Sum of time entry durations that have been created during last 7 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_most_active(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int workspace_id: Numeric ID of the workspace (required)
        :param int since: Filter activities since this date using UNIX timestamp.
        :return: list[ModelsMostActiveUser]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_workspace_most_active_with_http_info(workspace_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_workspace_most_active_with_http_info(workspace_id, **kwargs)  # noqa: E501
            return data

    def get_workspace_most_active_with_http_info(
        self, workspace_id: int, **kwargs
    ) -> list[ModelsMostActiveUser]:  # noqa: E501
        """Get most active users  # noqa: E501

        Dashboard's main purpose is to give an overview of what users in the workspace are doing and have been doing. The most active user object holds the data of the top 5 users who have tracked the most time during last 7 days. Most active user object has the following properties * user_id: user ID * duration: Sum of time entry durations that have been created during last 7 days.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_most_active_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int workspace_id: Numeric ID of the workspace (required)
        :param int since: Filter activities since this date using UNIX timestamp.
        :return: list[ModelsMostActiveUser]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["workspace_id", "since"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method get_workspace_most_active" % key)
            params[key] = val
        del params["kwargs"]
        # verify the required parameter "workspace_id" is set
        if self.api_client.client_side_validation and (
            "workspace_id" not in params or params["workspace_id"] is None  # noqa: E501
        ):
            raise ValueError(
                "Missing the required parameter `workspace_id` when calling `get_workspace_most_active`"  # noqa: E501
            )

        collection_formats = {}

        path_params = {}
        if "workspace_id" in params:
            path_params["workspace_id"] = params["workspace_id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "since" in params:
            form_params.append(("since", params["since"]))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = ["BasicAuth"]  # noqa: E501

        return self.api_client.call_api(
            "/workspaces/{workspace_id}/dashboard/most_active",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="list[ModelsMostActiveUser]",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_workspace_top_activity(self, workspace_id: int, **kwargs) -> list[DashboardAllActivities]:  # noqa: E501
        """Get top activities  # noqa: E501

        Dashboard's main purpose is to give an overview of what users in the workspace are doing and have been doing. Return objects are same as with the `/workspaces/{workspace_id}/dashboard/all_activity` request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_top_activity(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int workspace_id: Numeric ID of the workspace (required)
        :param int since: Filter activities since this date using UNIX timestamp.
        :return: list[DashboardAllActivities]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_workspace_top_activity_with_http_info(workspace_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_workspace_top_activity_with_http_info(workspace_id, **kwargs)  # noqa: E501
            return data

    def get_workspace_top_activity_with_http_info(
        self, workspace_id: int, **kwargs
    ) -> list[DashboardAllActivities]:  # noqa: E501
        """Get top activities  # noqa: E501

        Dashboard's main purpose is to give an overview of what users in the workspace are doing and have been doing. Return objects are same as with the `/workspaces/{workspace_id}/dashboard/all_activity` request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspace_top_activity_with_http_info(workspace_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int workspace_id: Numeric ID of the workspace (required)
        :param int since: Filter activities since this date using UNIX timestamp.
        :return: list[DashboardAllActivities]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["workspace_id", "since"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method get_workspace_top_activity" % key)
            params[key] = val
        del params["kwargs"]
        # verify the required parameter "workspace_id" is set
        if self.api_client.client_side_validation and (
            "workspace_id" not in params or params["workspace_id"] is None  # noqa: E501
        ):
            raise ValueError(
                "Missing the required parameter `workspace_id` when calling `get_workspace_top_activity`"  # noqa: E501
            )

        collection_formats = {}

        path_params = {}
        if "workspace_id" in params:
            path_params["workspace_id"] = params["workspace_id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "since" in params:
            form_params.append(("since", params["since"]))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = ["BasicAuth"]  # noqa: E501

        return self.api_client.call_api(
            "/workspaces/{workspace_id}/dashboard/top_activity",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="list[DashboardAllActivities]",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )
