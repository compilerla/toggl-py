"""
Public Toggl API. Note: We use BasicAuth in a specific way. By the standard you provide `Authentication` header with `base64(user_name:password)` as a `credential`. In our case it will be `base64(user_name:api_token)`.  # noqa: E501

This file is auto generated by the swagger code generator program.
Do not edit this file manually.

OpenAPI spec version: 9
Last changed: 2024-04-26T22:13:16.785Z
Generated by: https://github.com/compilerla/toggl-py/tree/main/codegen
"""

import re  # noqa: F401

from toggl.api_client import ApiClient


class MeApi:

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def delete_push_services(self, delete_push_services_unsubscribe, **kwargs):  # noqa: E501
        """PushServices  # noqa: E501

        Unregister Firebase token for current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_push_services(delete_push_services_unsubscribe, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PushDeletePushServicesUnsubscribe delete_push_services_unsubscribe: FirebaseToken (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.delete_push_services_with_http_info(delete_push_services_unsubscribe, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_push_services_with_http_info(delete_push_services_unsubscribe, **kwargs)  # noqa: E501
            return data

    def delete_push_services_with_http_info(self, delete_push_services_unsubscribe, **kwargs):  # noqa: E501
        """PushServices  # noqa: E501

        Unregister Firebase token for current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_push_services_with_http_info(delete_push_services_unsubscribe, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PushDeletePushServicesUnsubscribe delete_push_services_unsubscribe: FirebaseToken (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["delete_push_services_unsubscribe"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method delete_push_services" % key)
            params[key] = val
        del params["kwargs"]
        # verify the required parameter "delete_push_services_unsubscribe" is set
        if self.api_client.client_side_validation and (
            "delete_push_services_unsubscribe" not in params or params["delete_push_services_unsubscribe"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `delete_push_services_unsubscribe` when calling `delete_push_services`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "delete_push_services_unsubscribe" in params:
            body_params = params["delete_push_services_unsubscribe"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = ["BasicAuth"]  # noqa: E501

        return self.api_client.call_api(
            "/me/push_services",
            "DELETE",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="str",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_clients(self, **kwargs):  # noqa: E501
        """Clients  # noqa: E501

        Get Clients.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_clients(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int since: Retrieve clients created/modified/deleted since this date using UNIX timestamp.
        :return: list[ModelsClient]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_clients_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_clients_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_clients_with_http_info(self, **kwargs):  # noqa: E501
        """Clients  # noqa: E501

        Get Clients.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_clients_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int since: Retrieve clients created/modified/deleted since this date using UNIX timestamp.
        :return: list[ModelsClient]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["since"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method get_clients" % key)
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "since" in params:
            form_params.append(("since", params["since"]))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = ["BasicAuth"]  # noqa: E501

        return self.api_client.call_api(
            "/me/clients",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="list[ModelsClient]",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_lost_password(self, token_code, **kwargs):  # noqa: E501
        """LostPassword  # noqa: E501

        Verifies the user request to reset the password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lost_password(token_code, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token_code: Token code (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_lost_password_with_http_info(token_code, **kwargs)  # noqa: E501
        else:
            (data) = self.get_lost_password_with_http_info(token_code, **kwargs)  # noqa: E501
            return data

    def get_lost_password_with_http_info(self, token_code, **kwargs):  # noqa: E501
        """LostPassword  # noqa: E501

        Verifies the user request to reset the password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lost_password_with_http_info(token_code, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token_code: Token code (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["token_code"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method get_lost_password" % key)
            params[key] = val
        del params["kwargs"]
        # verify the required parameter "token_code" is set
        if self.api_client.client_side_validation and (
            "token_code" not in params or params["token_code"] is None
        ):  # noqa: E501
            raise ValueError("Missing the required parameter `token_code` when calling `get_lost_password`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "token_code" in params:
            body_params = params["token_code"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/me/lost_passwords",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="str",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_me(self, **kwargs):  # noqa: E501
        """Me  # noqa: E501

        Returns details for the current user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_me(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool with_related_data: Retrieve user related data (clients, projects, tasks, tags, workspaces, time entries, etc.)
        :return: RelatedUserWithRelated
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_me_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_me_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_me_with_http_info(self, **kwargs):  # noqa: E501
        """Me  # noqa: E501

        Returns details for the current user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_me_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool with_related_data: Retrieve user related data (clients, projects, tasks, tags, workspaces, time entries, etc.)
        :return: RelatedUserWithRelated
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["with_related_data"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method get_me" % key)
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "with_related_data" in params:
            query_params.append(("with_related_data", params["with_related_data"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = ["BasicAuth"]  # noqa: E501

        return self.api_client.call_api(
            "/me",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="RelatedUserWithRelated",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_me_features(self, **kwargs):  # noqa: E501
        """Features  # noqa: E501

        Get features.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_me_features(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[MeWorkspace]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_me_features_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_me_features_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_me_features_with_http_info(self, **kwargs):  # noqa: E501
        """Features  # noqa: E501

        Get features.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_me_features_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[MeWorkspace]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method get_me_features" % key)
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = ["BasicAuth"]  # noqa: E501

        return self.api_client.call_api(
            "/me/features",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="list[MeWorkspace]",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_me_flags(self, **kwargs):  # noqa: E501
        """Flags  # noqa: E501

        Returns flags for the current user. They will be represented by an object with dynamic string keys, where the value can be of any type.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_me_flags(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: UserFlags
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_me_flags_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_me_flags_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_me_flags_with_http_info(self, **kwargs):  # noqa: E501
        """Flags  # noqa: E501

        Returns flags for the current user. They will be represented by an object with dynamic string keys, where the value can be of any type.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_me_flags_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: UserFlags
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method get_me_flags" % key)
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = ["BasicAuth"]  # noqa: E501

        return self.api_client.call_api(
            "/me/flags",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="UserFlags",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_me_location(self, **kwargs):  # noqa: E501
        """User's last known location  # noqa: E501

        Returns the client's IP-based location. If no data is present, empty response will be yielded.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_me_location(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: MeUserLocationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_me_location_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_me_location_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_me_location_with_http_info(self, **kwargs):  # noqa: E501
        """User's last known location  # noqa: E501

        Returns the client's IP-based location. If no data is present, empty response will be yielded.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_me_location_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: MeUserLocationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method get_me_location" % key)
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/me/location",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="MeUserLocationResponse",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_me_notifications(self, **kwargs):  # noqa: E501
        """Notifications  # noqa: E501

        Get notifications.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_me_notifications(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[ModelsUserNotification]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_me_notifications_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_me_notifications_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_me_notifications_with_http_info(self, **kwargs):  # noqa: E501
        """Notifications  # noqa: E501

        Get notifications.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_me_notifications_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[ModelsUserNotification]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method get_me_notifications" % key)
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = ["BasicAuth"]  # noqa: E501

        return self.api_client.call_api(
            "/me/notifications",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="list[ModelsUserNotification]",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_me_projects(self, **kwargs):  # noqa: E501
        """Projects  # noqa: E501

        Get projects  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_me_projects(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str include_archived: Include archived projects.
        :param int since: Retrieve projects modified since this date using UNIX timestamp, including deleted ones.
        :return: list[ModelsProject]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_me_projects_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_me_projects_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_me_projects_with_http_info(self, **kwargs):  # noqa: E501
        """Projects  # noqa: E501

        Get projects  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_me_projects_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str include_archived: Include archived projects.
        :param int since: Retrieve projects modified since this date using UNIX timestamp, including deleted ones.
        :return: list[ModelsProject]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["include_archived", "since"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method get_me_projects" % key)
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "include_archived" in params:
            form_params.append(("include_archived", params["include_archived"]))  # noqa: E501
        if "since" in params:
            form_params.append(("since", params["since"]))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = ["BasicAuth"]  # noqa: E501

        return self.api_client.call_api(
            "/me/projects",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="list[ModelsProject]",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_me_projects_paginated(self, **kwargs):  # noqa: E501
        """ProjectsPaginated  # noqa: E501

        Get paginated projects.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_me_projects_paginated(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int start_project_id: Project ID to resume the next pagination from.
        :param int since: Retrieve projects created/modified/deleted since this date using UNIX timestamp.
        :param int per_page: Number of items per page, default 201.
        :return: list[ModelsProject]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_me_projects_paginated_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_me_projects_paginated_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_me_projects_paginated_with_http_info(self, **kwargs):  # noqa: E501
        """ProjectsPaginated  # noqa: E501

        Get paginated projects.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_me_projects_paginated_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int start_project_id: Project ID to resume the next pagination from.
        :param int since: Retrieve projects created/modified/deleted since this date using UNIX timestamp.
        :param int per_page: Number of items per page, default 201.
        :return: list[ModelsProject]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["start_project_id", "since", "per_page"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method get_me_projects_paginated" % key)
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "start_project_id" in params:
            form_params.append(("start_project_id", params["start_project_id"]))  # noqa: E501
        if "since" in params:
            form_params.append(("since", params["since"]))  # noqa: E501
        if "per_page" in params:
            form_params.append(("per_page", params["per_page"]))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = ["BasicAuth"]  # noqa: E501

        return self.api_client.call_api(
            "/me/projects/paginated",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="list[ModelsProject]",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_me_timesheets(self, **kwargs):  # noqa: E501
        """User's Timesheets  # noqa: E501

        Returns the timehseets for the current user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_me_timesheets(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[ModelsTimesheet]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_me_timesheets_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_me_timesheets_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_me_timesheets_with_http_info(self, **kwargs):  # noqa: E501
        """User's Timesheets  # noqa: E501

        Returns the timehseets for the current user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_me_timesheets_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[ModelsTimesheet]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method get_me_timesheets" % key)
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = ["BasicAuth"]  # noqa: E501

        return self.api_client.call_api(
            "/me/timesheets",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="list[ModelsTimesheet]",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_me_track_reminders(self, **kwargs):  # noqa: E501
        """TrackReminders  # noqa: E501

        Returns a list of track reminders.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_me_track_reminders(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[ModelsTrackReminder]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_me_track_reminders_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_me_track_reminders_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_me_track_reminders_with_http_info(self, **kwargs):  # noqa: E501
        """TrackReminders  # noqa: E501

        Returns a list of track reminders.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_me_track_reminders_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[ModelsTrackReminder]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method get_me_track_reminders" % key)
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = ["BasicAuth"]  # noqa: E501

        return self.api_client.call_api(
            "/me/track_reminders",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="list[ModelsTrackReminder]",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_organizations(self, **kwargs):  # noqa: E501
        """Organizations that a user is part of  # noqa: E501

        Get all organizations a given user is part of.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_organizations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[ModelsMeOrganization]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_organizations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_organizations_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_organizations_with_http_info(self, **kwargs):  # noqa: E501
        """Organizations that a user is part of  # noqa: E501

        Get all organizations a given user is part of.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_organizations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[ModelsMeOrganization]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method get_organizations" % key)
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/me/organizations",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="list[ModelsMeOrganization]",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_push_services(self, **kwargs):  # noqa: E501
        """PushServices  # noqa: E501

        Get list of firebase tokens registered for current user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_push_services(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_push_services_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_push_services_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_push_services_with_http_info(self, **kwargs):  # noqa: E501
        """PushServices  # noqa: E501

        Get list of firebase tokens registered for current user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_push_services_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method get_push_services" % key)
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = ["BasicAuth"]  # noqa: E501

        return self.api_client.call_api(
            "/me/push_services",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="list[str]",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_tags(self, **kwargs):  # noqa: E501
        """Tags  # noqa: E501

        Returns tags for the current user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tags(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int since: Retrieve tags modified/deleted since this date using UNIX timestamp.
        :return: list[ModelsTag]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_tags_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_tags_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_tags_with_http_info(self, **kwargs):  # noqa: E501
        """Tags  # noqa: E501

        Returns tags for the current user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tags_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int since: Retrieve tags modified/deleted since this date using UNIX timestamp.
        :return: list[ModelsTag]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["since"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method get_tags" % key)
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "since" in params:
            form_params.append(("since", params["since"]))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = ["BasicAuth"]  # noqa: E501

        return self.api_client.call_api(
            "/me/tags",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="list[ModelsTag]",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_tasks(self, **kwargs):  # noqa: E501
        """Tasks  # noqa: E501

        Returns tasks from projects in which the user is participating.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tasks(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int since: Retrieve tasks created/modified/deleted since this date using UNIX timestamp.
        :param str include_not_active: Include tasks marked as done.
        :return: list[ModelsTask]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_tasks_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_tasks_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_tasks_with_http_info(self, **kwargs):  # noqa: E501
        """Tasks  # noqa: E501

        Returns tasks from projects in which the user is participating.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tasks_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int since: Retrieve tasks created/modified/deleted since this date using UNIX timestamp.
        :param str include_not_active: Include tasks marked as done.
        :return: list[ModelsTask]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["since", "include_not_active"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method get_tasks" % key)
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "since" in params:
            form_params.append(("since", params["since"]))  # noqa: E501
        if "include_not_active" in params:
            form_params.append(("include_not_active", params["include_not_active"]))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = ["BasicAuth"]  # noqa: E501

        return self.api_client.call_api(
            "/me/tasks",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="list[ModelsTask]",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_web_timer(self, **kwargs):  # noqa: E501
        """WebTimer  # noqa: E501

        Get web timer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_web_timer(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_web_timer_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_web_timer_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_web_timer_with_http_info(self, **kwargs):  # noqa: E501
        """WebTimer  # noqa: E501

        Get web timer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_web_timer_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method get_web_timer" % key)
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = ["BasicAuth"]  # noqa: E501

        return self.api_client.call_api(
            "/me/web-timer",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="str",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def get_workspaces(self, **kwargs):  # noqa: E501
        """Workspaces  # noqa: E501

        Lists workspaces for given user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspaces(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int since: Retrieve workspaces created/modified/deleted since this date using UNIX timestamp, including the dates a workspace member got added, removed or updated in the workspace.
        :return: list[WorkspaceWorkspace]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.get_workspaces_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_workspaces_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_workspaces_with_http_info(self, **kwargs):  # noqa: E501
        """Workspaces  # noqa: E501

        Lists workspaces for given user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_workspaces_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int since: Retrieve workspaces created/modified/deleted since this date using UNIX timestamp, including the dates a workspace member got added, removed or updated in the workspace.
        :return: list[WorkspaceWorkspace]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["since"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method get_workspaces" % key)
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if "since" in params:
            form_params.append(("since", params["since"]))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = ["BasicAuth"]  # noqa: E501

        return self.api_client.call_api(
            "/me/workspaces",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="list[WorkspaceWorkspace]",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def me_logged_get(self, **kwargs):  # noqa: E501
        """Logged  # noqa: E501

        Used to check if authentication works.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.me_logged_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.me_logged_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.me_logged_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def me_logged_get_with_http_info(self, **kwargs):  # noqa: E501
        """Logged  # noqa: E501

        Used to check if authentication works.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.me_logged_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method me_logged_get" % key)
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/me/logged",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def post_close_account(self, **kwargs):  # noqa: E501
        """CloseAccount  # noqa: E501

        Close Account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_close_account(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.post_close_account_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_close_account_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_close_account_with_http_info(self, **kwargs):  # noqa: E501
        """CloseAccount  # noqa: E501

        Close Account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_close_account_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method post_close_account" % key)
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = ["BasicAuth"]  # noqa: E501

        return self.api_client.call_api(
            "/me/close_account",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="str",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def post_lost_password(self, post_lost_password, **kwargs):  # noqa: E501
        """LostPassword  # noqa: E501

        Handles the users request to reset the password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_lost_password(post_lost_password, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ModelsLostPassword post_lost_password: Lost Password Parameters (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.post_lost_password_with_http_info(post_lost_password, **kwargs)  # noqa: E501
        else:
            (data) = self.post_lost_password_with_http_info(post_lost_password, **kwargs)  # noqa: E501
            return data

    def post_lost_password_with_http_info(self, post_lost_password, **kwargs):  # noqa: E501
        """LostPassword  # noqa: E501

        Handles the users request to reset the password.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_lost_password_with_http_info(post_lost_password, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ModelsLostPassword post_lost_password: Lost Password Parameters (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["post_lost_password"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method post_lost_password" % key)
            params[key] = val
        del params["kwargs"]
        # verify the required parameter "post_lost_password" is set
        if self.api_client.client_side_validation and (
            "post_lost_password" not in params or params["post_lost_password"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `post_lost_password` when calling `post_lost_password`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "post_lost_password" in params:
            body_params = params["post_lost_password"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/me/lost_passwords",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="str",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def post_lost_password_confirm(self, post_new_password, **kwargs):  # noqa: E501
        """LostPassword conformation  # noqa: E501

        Handles lost password request confirmation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_lost_password_confirm(post_new_password, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MeLostPasswordPayload post_new_password: New Password Data (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.post_lost_password_confirm_with_http_info(post_new_password, **kwargs)  # noqa: E501
        else:
            (data) = self.post_lost_password_confirm_with_http_info(post_new_password, **kwargs)  # noqa: E501
            return data

    def post_lost_password_confirm_with_http_info(self, post_new_password, **kwargs):  # noqa: E501
        """LostPassword conformation  # noqa: E501

        Handles lost password request confirmation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_lost_password_confirm_with_http_info(post_new_password, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MeLostPasswordPayload post_new_password: New Password Data (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["post_new_password"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method post_lost_password_confirm" % key)
            params[key] = val
        del params["kwargs"]
        # verify the required parameter "post_new_password" is set
        if self.api_client.client_side_validation and (
            "post_new_password" not in params or params["post_new_password"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `post_new_password` when calling `post_lost_password_confirm`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "post_new_password" in params:
            body_params = params["post_new_password"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/me/lost_passwords/confirm",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="str",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def post_me_accept_tos(self, **kwargs):  # noqa: E501
        """AcceptTOS  # noqa: E501

        Accepts the last version of the Terms of Service for the current user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_me_accept_tos(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.post_me_accept_tos_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.post_me_accept_tos_with_http_info(**kwargs)  # noqa: E501
            return data

    def post_me_accept_tos_with_http_info(self, **kwargs):  # noqa: E501
        """AcceptTOS  # noqa: E501

        Accepts the last version of the Terms of Service for the current user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_me_accept_tos_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method post_me_accept_tos" % key)
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = ["BasicAuth"]  # noqa: E501

        return self.api_client.call_api(
            "/me/accept_tos",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="str",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def post_me_disable_product_emails(self, disable_code, **kwargs):  # noqa: E501
        """Disable product emails  # noqa: E501

        Disable product emails.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_me_disable_product_emails(disable_code, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str disable_code: Disable Code (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.post_me_disable_product_emails_with_http_info(disable_code, **kwargs)  # noqa: E501
        else:
            (data) = self.post_me_disable_product_emails_with_http_info(disable_code, **kwargs)  # noqa: E501
            return data

    def post_me_disable_product_emails_with_http_info(self, disable_code, **kwargs):  # noqa: E501
        """Disable product emails  # noqa: E501

        Disable product emails.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_me_disable_product_emails_with_http_info(disable_code, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str disable_code: Disable Code (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["disable_code"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method post_me_disable_product_emails" % key)
            params[key] = val
        del params["kwargs"]
        # verify the required parameter "disable_code" is set
        if self.api_client.client_side_validation and (
            "disable_code" not in params or params["disable_code"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `disable_code` when calling `post_me_disable_product_emails`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "disable_code" in params:
            path_params["disable_code"] = params["disable_code"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/me/disable_product_emails/{disable_code}",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="str",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def post_me_disable_weekly_report(self, weekly_report_code, **kwargs):  # noqa: E501
        """Disable weekly report  # noqa: E501

        Disable weekly report.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_me_disable_weekly_report(weekly_report_code, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str weekly_report_code: Weekly report code (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.post_me_disable_weekly_report_with_http_info(weekly_report_code, **kwargs)  # noqa: E501
        else:
            (data) = self.post_me_disable_weekly_report_with_http_info(weekly_report_code, **kwargs)  # noqa: E501
            return data

    def post_me_disable_weekly_report_with_http_info(self, weekly_report_code, **kwargs):  # noqa: E501
        """Disable weekly report  # noqa: E501

        Disable weekly report.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_me_disable_weekly_report_with_http_info(weekly_report_code, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str weekly_report_code: Weekly report code (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["weekly_report_code"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method post_me_disable_weekly_report" % key)
            params[key] = val
        del params["kwargs"]
        # verify the required parameter "weekly_report_code" is set
        if self.api_client.client_side_validation and (
            "weekly_report_code" not in params or params["weekly_report_code"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `weekly_report_code` when calling `post_me_disable_weekly_report`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "weekly_report_code" in params:
            path_params["weekly_report_code"] = params["weekly_report_code"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/me/disable_weekly_report/{weekly_report_code}",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="str",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def post_me_flags(self, post_flags, **kwargs):  # noqa: E501
        """Flags  # noqa: E501

        Add flags for the current user. The current limits are 4 flags per request, 128 flags in total. Keys and values can be up to 32 and 64 characters, respectively.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_me_flags(post_flags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UserFlags post_flags: flags (required)
        :return: UserFlags
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.post_me_flags_with_http_info(post_flags, **kwargs)  # noqa: E501
        else:
            (data) = self.post_me_flags_with_http_info(post_flags, **kwargs)  # noqa: E501
            return data

    def post_me_flags_with_http_info(self, post_flags, **kwargs):  # noqa: E501
        """Flags  # noqa: E501

        Add flags for the current user. The current limits are 4 flags per request, 128 flags in total. Keys and values can be up to 32 and 64 characters, respectively.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_me_flags_with_http_info(post_flags, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UserFlags post_flags: flags (required)
        :return: UserFlags
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["post_flags"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method post_me_flags" % key)
            params[key] = val
        del params["kwargs"]
        # verify the required parameter "post_flags" is set
        if self.api_client.client_side_validation and (
            "post_flags" not in params or params["post_flags"] is None
        ):  # noqa: E501
            raise ValueError("Missing the required parameter `post_flags` when calling `post_me_flags`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "post_flags" in params:
            body_params = params["post_flags"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = ["BasicAuth"]  # noqa: E501

        return self.api_client.call_api(
            "/me/flags",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="UserFlags",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def post_push_services(self, post_push_services_subscribe, **kwargs):  # noqa: E501
        """PushServices  # noqa: E501

        Register Firebase token for current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_push_services(post_push_services_subscribe, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PushPostPushServicesSubscribe post_push_services_subscribe: FirebaseToken (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.post_push_services_with_http_info(post_push_services_subscribe, **kwargs)  # noqa: E501
        else:
            (data) = self.post_push_services_with_http_info(post_push_services_subscribe, **kwargs)  # noqa: E501
            return data

    def post_push_services_with_http_info(self, post_push_services_subscribe, **kwargs):  # noqa: E501
        """PushServices  # noqa: E501

        Register Firebase token for current user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_push_services_with_http_info(post_push_services_subscribe, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PushPostPushServicesSubscribe post_push_services_subscribe: FirebaseToken (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["post_push_services_subscribe"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method post_push_services" % key)
            params[key] = val
        del params["kwargs"]
        # verify the required parameter "post_push_services_subscribe" is set
        if self.api_client.client_side_validation and (
            "post_push_services_subscribe" not in params or params["post_push_services_subscribe"] is None
        ):  # noqa: E501
            raise ValueError(
                "Missing the required parameter `post_push_services_subscribe` when calling `post_push_services`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "post_push_services_subscribe" in params:
            body_params = params["post_push_services_subscribe"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = ["BasicAuth"]  # noqa: E501

        return self.api_client.call_api(
            "/me/push_services",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="str",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def put_me(self, payload, **kwargs):  # noqa: E501
        """Me  # noqa: E501

        Updates details for the current user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_me(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MePayload payload: Update user parameters (required)
        :return: ModelsTogglUser
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.put_me_with_http_info(payload, **kwargs)  # noqa: E501
        else:
            (data) = self.put_me_with_http_info(payload, **kwargs)  # noqa: E501
            return data

    def put_me_with_http_info(self, payload, **kwargs):  # noqa: E501
        """Me  # noqa: E501

        Updates details for the current user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_me_with_http_info(payload, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MePayload payload: Update user parameters (required)
        :return: ModelsTogglUser
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["payload"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method put_me" % key)
            params[key] = val
        del params["kwargs"]
        # verify the required parameter "payload" is set
        if self.api_client.client_side_validation and ("payload" not in params or params["payload"] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `payload` when calling `put_me`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if "payload" in params:
            body_params = params["payload"]
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json", "text/plain"])  # noqa: E501

        # HTTP header `Content-Type`
        header_params["Content-Type"] = self.api_client.select_header_content_type(  # noqa: E501
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = ["BasicAuth"]  # noqa: E501

        return self.api_client.call_api(
            "/me",
            "PUT",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="ModelsTogglUser",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def put_notifications(self, notification_id, **kwargs):  # noqa: E501
        """Notifications  # noqa: E501

        Mark notification seen.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_notifications(notification_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int notification_id: Notification ID. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.put_notifications_with_http_info(notification_id, **kwargs)  # noqa: E501
        else:
            (data) = self.put_notifications_with_http_info(notification_id, **kwargs)  # noqa: E501
            return data

    def put_notifications_with_http_info(self, notification_id, **kwargs):  # noqa: E501
        """Notifications  # noqa: E501

        Mark notification seen.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_notifications_with_http_info(notification_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int notification_id: Notification ID. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["notification_id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in params["kwargs"].items():
            if key not in all_params:
                raise TypeError("Got an unexpected keyword argument '%s'" " to method put_notifications" % key)
            params[key] = val
        del params["kwargs"]
        # verify the required parameter "notification_id" is set
        if self.api_client.client_side_validation and (
            "notification_id" not in params or params["notification_id"] is None
        ):  # noqa: E501
            raise ValueError("Missing the required parameter `notification_id` when calling `put_notifications`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "notification_id" in params:
            path_params["notification_id"] = params["notification_id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501

        # Authentication setting
        auth_settings = ["BasicAuth"]  # noqa: E501

        return self.api_client.call_api(
            "/me/notifications/{notification_id}/seen",
            "POST",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="str",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )
